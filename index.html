<!DOCTYPE html>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<script src='vendor/require.js/require.js'></script>
<script src='bower_components/threejs/build/three.min.js'></script>
<script src='vendor/three.js/examples/js/controls/OrbitControls.js'></script>
<script src="vendor/physijs/physi.js"></script>

<script src="fonts/helvetiker_bold.typeface.js"></script>
<script src="fonts/helvetiker_regular.typeface.js"></script>

<style>
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
</style>

<body style='margin: 0px; overflow: hidden; text-align:center;'>

<script>
require([], function(){
	'use strict';

    Physijs.scripts.worker = 'vendor/physijs/physijs_worker.js';
    Physijs.scripts.ammo = '/bower_components/ammo.js/builds/ammo.js';

	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	var letterPosition = {
		"q": 0,
		"w": 10,
		"e": 20,
		"r": 30,
		"t": 40,
		"y": 50,
		"u": 60,
		"i": 70,
		"o": 80,
		"p": 90,
		"a": 3,
		"s": 13,
		"d": 23,
		"f": 33,
		"g": 43,
		"h": 53,
		"j": 63,
		"k": 73,
		"l": 83,
		"z": 6,
		"x": 16,
		"c": 26,
		"v": 36,
		"b": 46,
		"n": 56,
		"m": 66
	};
	var typeMaterial = new THREE.MeshPhongMaterial({
      color: 0xdddddd
  });

	var screenWidth = window.innerWidth;
	var keyWidth = 10;
	var pageWidth = 0.5;

	// array of functions for the rendering loop
	var onRenderFcts = [];

	var scene	= new Physijs.Scene({reportsize: 50, fixedTimeStep: 1 / 60});
	//scene.setGravity(new THREE.Vector3( 0, -9.8, 0 )); // set gravity
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
	camera.position.z = 2;
	var controls	= new THREE.OrbitControls(camera);

	document.onkeypress = function(e) {
	    e = e || window.event;
	    var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
	    if (charCode) {
	    	var charString = String.fromCharCode(charCode);
        var letterObject = createLetter(charString);
        letterObject.position.x = (letterPosition[charString] + (keyWidth/2)) / 100 - pageWidth - (letterObject.textWidth/2);
        letterObject.position.y = 0;

        
        console.log(letterObject);
        
        //letterObject.applyCentralImpulse(new THREE.Vector3( 0, -200, 0 ));
	    }
	};

	// init renderer
	var renderer	= new THREE.WebGLRenderer({
		antialias	: true,
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 1)
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

	var floor = new Physijs.BoxMesh( new THREE.BoxGeometry( 5, 0.5, 5 ), new THREE.MeshBasicMaterial({ color: 0x888888 }), 0);
	floor.position.y = -1;
	scene.add(floor);
	

	//////////////////////////////////////////////////////////////////////////////////
	//		render 
	//////////////////////////////////////////////////////////////////////////////////

	// handle window resize
	window.addEventListener('resize', function(){
		renderer.setSize( window.innerWidth, window.innerHeight )
		camera.aspect	= window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()		
	}, false)

	// render the scene
	onRenderFcts.push(function(){
		renderer.render( scene, camera );
		scene.simulate(); // run physics	
	})
	
	// run the rendering loop
	var lastTimeMsec = null;

	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame(animate);
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		});
	});

	function createLetter(letter) {
		var textGeom = new THREE.TextGeometry( letter, {
      font:   	"helvetiker",
	    height: 	0.03,
	    size:    	randomNumberBetween(0.01, 0.05),
	    style:   	"normal",
	    weight: 	"normal"
    }, 1);
    textGeom.computeBoundingBox();
    var textMesh = new Physijs.BoxMesh(textGeom, typeMaterial);
    textMesh.textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
    
    scene.add(textMesh);

    textMesh.applyCentralImpulse(new THREE.Vector3(0,0,-1));

		return  textMesh;
	}

	function randomNumberBetween(min,max) {
	    return Math.random()*(max-min)+min;
	}

	// (function addUtilMarkers () {
	// 	var geometry = new THREE.BoxGeometry(0.001, 2.01, 0.001);
	// 	var material = new THREE.MeshLambertMaterial( { color: 0xdd0000, shading: THREE.FlatShading } );

	// 	var mesh = new Physijs.Mesh( geometry, material );
	// 	scene.add( mesh );

	// 	var geometry = new THREE.BoxGeometry(2.01, 0.001, 0.001);
	// 	var material = new THREE.MeshLambertMaterial( { color: 0xdd0000, shading: THREE.FlatShading } );

	// 	mesh = new THREE.Mesh( geometry, material );
	// 	scene.add( mesh );
	// })();
});
</script>
</body>
